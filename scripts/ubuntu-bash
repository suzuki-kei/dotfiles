#!/usr/bin/env bash

set -eu -o pipefail

declare -r NAME="$(basename "${BASH_SOURCE}")"
declare -r BASE_DIR="$(cd "$(dirname "${BASH_SOURCE}")" && pwd)"
source "${BASE_DIR}/_internal"

declare -r DOCKER_IMAGE_NAME="$(basename "$0"):latest"
declare -r DOCKERFILE_DIR="${BASE_DIR}/../dockerfiles/${NAME}"

declare -r EXIT_STATUS_SUCCESS=0
declare -r EXIT_STATUS_INVALID_ARGUMENT=1

declare -r USAGE=`cat <<EOS | strip_heredoc
    NAME
        ${NAME} - operates ${NAME} docker image

    SYNOPSIS
        ${NAME} [OPTION...] [SUBCOMMAND]

    DESCRIPTION
        Operates the ${DOCKER_IMAGE_NAME} docker image.

        see SUBCOMMANDS section for details.

    OPTIONS
        -h, --help
            Print the help message.

    SUBCOMMANDS
        build
            Build docker image.

        help
            Print the help message.

        rmi
            Remove docker image.

        run
            Run docker container.

    EXIT STATUS
        ${EXIT_STATUS_SUCCESS} if successfly.
        ${EXIT_STATUS_INVALID_ARGUMENT} if the argument is invalid.
EOS`

function main
{
    parse_options "$@"
    set -- "${OPTION_ARGS[@]}"

    if ${OPTION_HELP}; then
        print_help
        exit ${EXIT_STATUS_SUCCESS}
    fi

    subcommand_${OPTION_SUBCOMMAND}
    exit ${EXIT_STATUS_SUCCESS}
}

function print_help
{
    echo "${USAGE}"
}

function parse_options
{
    for option in "$@"
    do
        case "${option}" in
            build)
                OPTION_SUBCOMMAND=build
                ;;
            help | -h | --help)
                OPTION_SUBCOMMAND=help
                ;;
            rmi)
                OPTION_SUBCOMMAND=rmi
                ;;
            run)
                OPTION_SUBCOMMAND=run
                ;;
            *)
                echo "illegal option(s) -- $@" >&2
                exit ${EXIT_STATUS_INVALID_ARGUMENT}
                ;;
        esac
    done

    shift $((OPTIND - 1))
    declare -agr OPTION_ARGS=("$@")
    declare -gr OPTION_HELP=${OPTION_HELP:-false}
    declare -gr OPTION_SUBCOMMAND=${OPTION_SUBCOMMAND:-run}
}

function subcommand_build
{
    declare -r work_dir="${DOCKERFILE_DIR}/files"
    declare -r dotfiles_target_dir="${work_dir}/dotfiles"
    declare -r dotfiles_source_dir="${BASE_DIR}/../dotfiles"

    mkdir -p "${dotfiles_target_dir}"

    cp -p \
        "${dotfiles_source_dir}/.bash_profile" \
        "${dotfiles_source_dir}/.bashrc" \
        "${dotfiles_source_dir}/.bashrc-common" \
        "${dotfiles_source_dir}/.bashrc-linux" \
        "${dotfiles_source_dir}/.bashrc-mac" \
        "${dotfiles_source_dir}/.vimrc" \
        "${dotfiles_target_dir}"

    export DOCKER_SCAN_SUGGEST=false
    docker build -t "${DOCKER_IMAGE_NAME}" "${DOCKERFILE_DIR}"

    rm -rf "${work_dir}"
}

function subcommand_help
{
    print_help
}

function subcommand_rmi
{
    if docker images --format '{{.Repository}}:{{.Tag}}' | grep -E "^${DOCKER_IMAGE_NAME}\$"; then
        docker rmi "${DOCKER_IMAGE_NAME}"
    fi
}

function subcommand_run
{
    docker run -it --rm --volume "$(pwd):/root/workspace:ro" "${DOCKER_IMAGE_NAME}" || true
}

if [[ "$0" == "${BASH_SOURCE}" ]]; then
    main "$@"
fi

